# 基本类型
- 数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
- 字符串：字符串字面量和字符串切片 `&str`
- 布尔类型： true和false
- 字符类型: 表示单个Unicode字符，存储为4个字节
- 单元类型: 即 `()` ，其唯一的值也是 `()`

## 数字类型
- i 为integer， 反之 u 为无符号 usigned 类型（非负数）；
- 符号类型规定的数字范围：`-(2n - 1) ~ 2n - 1 - 1`, i8: `-(27) ~ 27 - 1`，即 -128 ~ 127
- isize 和 usize 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。
- 整型溢出: u8类型的变量，值设为256时，debug会报错，release会将其变为0，如果是257，release会将其变为1；
- 处理数字溢出：
>使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
>如果使用 checked_* 方法时发生溢出，则返回 None 值
>使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
>使用 saturating_* 方法使值达到最小值或最大值
- 默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。
- Rust 的数值上可以使用方法.
```rust
13.14_f32.round();
42_f32.sqrt();
```
- 序列
  - `1..5`, `1..=5`, `'a'..='z'`

### 浮点数陷阱
- 浮点数往往是你想要数字的近似表达，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
- 浮点数在某些特性上是反直觉的，缺少`std::cmp::Eq`接口
  - 避免在浮点数上测试相等性
    - `assert!(0.1 + 0.2 == 0.3);` panic!
  - 当结果在数学上可能存在未定义时，需要格外的小心

### 其他数字类型

- 社区Rust 数值库：num。
>有理数和复数
>任意大小的整数和任意精度的浮点数
>固定精度的十进制小数，常用于货币相关的场景

## 字符
- Rust 的字符只能用 `''` 来表示， `""` 是留给字符串的
- 字符串字面值是不可变的，因为被硬编码到程序代码中

## 单元类型
- 不占用任何内存。
- () 作为 map 的值，表示我们不关注具体的值，只关注 key



---

# 表达式与语句
- 表达式不能包含分号，一旦你在表达式后加上分号，它就会变成一条语句，再也不会返回一个值

# 函数
- 函数名和变量名使用蛇形命名法(snake case)
- 函数的位置可以随便放
- 返回类型为`!`表示永远不返回，返回类型为`()`表示无返回值

# 所有权原则
- Rust 中每一个值都 有且只有 一个所有者(变量)
- 当所有者(变量)离开作用域范围时，这个值将被丢弃(free)

## 栈与堆
- 栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。高速缓存和内存的访问速度差异在 10 倍以上。
- 基本类型都是存在栈，如字符类型；可变类型都存在堆，如String类型

- 所有权与**栈**: 当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除
- 所有权与**堆**：....

- String 类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成；堆指针指向了真实存储字符串内容的堆内存；容量是堆内存分配空间的大小，长度是目前已经使用的大小。

- 假定一个值可以拥有两个所有者，会产生二次释放的错误，导致内存污染；

## 拷贝
- 如果实在需要拷贝，使用深拷贝（clone）； clone 会极大的降低程序性能
- 浅拷贝（copy）只发生在栈上

## 引用

### 可变引用
1. 可变引用同时只能存在一个
- 同一作用域，同个数据，只能有一个可变引用。
- 这种限制的好处就是使 Rust 在编译期就避免**数据竞争**，数据竞争可由以下行为造成：
>- 两个或更多的指针同时访问同一数据
>- 至少有一个指针被用来写入数据
>- 没有同步数据访问的机制

2. 不可变引用可以有多个，但是，可变引用与不可变引用不能同时存在
```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题
```
3. 引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同(变量的作用域从创建持续到某一个花括号.)
- 对于这种编译器优化行为，Rust 专门起了一个名字 —— `Non-Lexical Lifetimes(NLL)`，专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。
```rust
fn main() {
   let mut s = String::from("hello");

    let r1 = &s; 
    let r2 = &s; 
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束

    let r3 = &mut s; 
    println!("{}", r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
```
4. 引用必须总是有效的
- **悬垂引用**也叫做**悬垂指针**，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在
```rust

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}// 这里 s 离开作用域并被丢弃。其内存被释放。
  // 报错！
```
**借用规则总结**
- 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
- 引用必须总是有效的

# str（切片） 和 String 类型
在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是UTF8字符的边界，例如中文在UTF8中占用三个字节,下面的代码就会崩溃:
```rust
let cns = "中国人";
let a = &cns[0..2];
println!("{}", a);
```
- 字面量是字符串切片，即字符串的片段引用，所以不可变。
- Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF8 编码，也就是字符所占的字节数是变化的(1 - 4)
- Rust 用户提到字符串时，往往指的就是 String 类型和 &str 字符串切片类型，这两个类型都是 UTF8 编码。

- rust不允许字符串索引的原因
1. 有些字符串其实有隐藏字符，如音调，换行符
2. 索引时，期望它的性能表现是 O(1)，然而对于 String 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符。

- 如果不清楚字符串的字节长度，切片可能导致错误
```rust

let hello = "中国人";
// “中”有3字节，这里只截取了2字节会导致错误
let s = &hello[0..2];
```
- 如果想精确地按照一般人的思维去截取，可以使用`utf8_slice`这个库


# 结构体
- 元结构体(Unit-**like** Struct)
  - 如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用 元结构体
- 结构体调用方法时，根据方法的签名决定要不要自动为主对象加引用"&"或可变"mut"，开发者无需自己添加
```rust
impl P {
  distance(&self, other: &P) -> f64 {
    ...
  }
}
...
p1.distance(&p2);
// 等同
(&p1).distance(&ps)
```


# 数组
- 最常用的数组有两种，**第一种是速度很快但是长度固定的** array，第二种是可动态增长的但是有性能损耗的 Vector，在本书中，我们称 array 为数组，Vector 为动态数组。
- 在 Rust 中无论是 String 还是 Vector，它们都是 Rust 的高级类型：**集合类型**







# 其他
- 手动清理内存 `drop`
